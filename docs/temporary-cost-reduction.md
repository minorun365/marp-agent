# Bedrock LLM推論コスト削減計画

## 背景

- AWS利用料の99%がBedrock LLM推論コスト（主にClaude Sonnet）
- 代替モデル（Haiku, Kimi K2.5等）は品質低下やツールユース不安定で単純置換が困難
  - Haikuはスライド出力品質が低下、Kimi K2.5はツールユースが不安定でアプリが途中停止する
  - DeepSeek V3.2はツールユース安定・Haikuと同等の賢さだが、スライド品質はSonnetに劣る
- アプローチを変えて、アーキテクチャレベルでトークン消費を最適化する

## 現状分析（CloudWatch Logs実測データ）

### コスト概要

| 指標 | 数値 |
|------|------|
| 1日のコスト | 約$30/日（月約$900） |
| Claude Sonnet 4.5 | $26.45/日（88.7%） |
| Claude Opus 4.6 | $3.37/日（11.3%） |
| 入力トークン比率 | **95.7%** ← 削減ターゲット |
| 出力トークン比率 | 4.3% |
| キャッシュヒット率 | 約9%（ピーク時26%） |
| 推定セッション数 | 約1,300/日 |

### 1セッションあたりのトークン内訳

| 要素 | トークン数 | 備考 |
|------|-----------|------|
| System prompt + ツール定義 | ~1,500 | キャッシュ対象 |
| Web検索結果 | ~2,000 | **最大の削減ポイント** |
| 会話履歴 | ~700 | ターンが増えると累積 |
| ユーザーメッセージ | ~300 | |
| **入力合計** | **~4,500** | |
| 出力（スライドMD） | ~1,200 | |

### ピーク時の消費

- ピーク時（日本時間17:57）: 2,539,025 tokens → $8.50/時間
- 平均時間帯: 362,179 tokens → $1.33/時間
- 全日のトークンの**35%を1時間**で消費

### 現在のキャッシュ設定

- `cache_prompt="default"`, `cache_tools="default"` で System prompt + ツール定義をキャッシュ
- セッション再利用率が高い時間帯ではキャッシュ率26%を達成
- ただし全体平均は9%にとどまり、履歴が膨らむと「キャッシュされない新規部分」も増大

---

## モデル料金比較（2026年2月時点）

### 入出力トークン単価（/1M tokens）

| モデル | 入力 | 出力 | キャッシュRead | キャッシュWrite(5m) | Sonnet比（入力） |
|--------|------|------|---------------|-------------------|-----------------|
| **Claude Sonnet 4.5** | $3.00 | $15.00 | $0.30 | $3.75 | 1.0x |
| **Claude Opus 4.6** | $5.00 | $25.00 | $0.50 | $6.25 | 1.7x |
| **Claude Haiku 4.5** | $1.00 | $5.00 | $0.10 | $1.25 | **0.33x** |
| **Amazon Nova Pro** | $0.80 | $3.20 | - | - | **0.27x** |
| **DeepSeek V3.2** (Bedrock) | ~$0.28 | ~$0.42 | - | - | **0.09x** |

> 出典: [Claude Pricing](https://platform.claude.com/docs/en/about-claude/pricing), [Bedrock Pricing](https://aws.amazon.com/bedrock/pricing/), [Nova Pricing](https://aws.amazon.com/nova/pricing/)

### 重要な料金メカニズム

| 機能 | 割引率 | 備考 |
|------|--------|------|
| **プロンプトキャッシュ（Read）** | **-90%** | 入力$3.00 → $0.30 |
| **バッチ推論** | **-50%** | 非リアルタイム処理向け |
| **グローバルエンドポイント** | 基準価格 | リージョナルは+10%プレミアム |

---

## 施策一覧

### 【既存施策】施策1: Web検索サブエージェント（マルチエージェント化）

- **効果**: 大（入力トークン約33%削減）
- **工数**: 中
- **状態**: 断念（要約・ノイズ除去いずれもサブエージェント経由で品質低下が不可避）

#### 構成（実装済み）

```
[メインAgent: Sonnet]
    |
    +-- search_and_summarize ツール呼び出し
    |       |
    |       [サブAgent: DeepSeek V3.2]  ← callback_handler=None
    |           +-- web_search（Tavily API: basic / 3件）
    |           +-- 検索結果を要約（重要ポイントだけ抽出）
    |           +-- 要約テキストを返す（~500トークン）
    |
    +-- メイン履歴には要約のみが入る（2,000 → 500トークンに圧縮）
    +-- output_slide でスライド生成
```

#### 実装時に判明した技術的課題

| 課題 | 詳細 | 対処 |
|------|------|------|
| **並列呼び出しエラー** | メインAgentが`search_and_summarize`を2つ同時にtool_use → シングルトンのサブAgentが`Concurrent invocations not supported`エラー | サブAgentを毎回新規作成（`_create_search_agent()`）で解決 |
| **検索クエリのフロント通知** | サブAgent内部のweb_searchイベントは親Agentのcallback_handlerに自動伝播しない（Strands Agentsの仕様） | `search_and_summarize`のquery引数をフロントに`web_search`として送信（互換性マッピング）で解決 |
| **APIキー未設定（sandbox固有）** | 既存コンテナが古い環境変数のまま動作 | セッション停止 or 新規セッションで解決 |

#### テスト結果と品質問題（2026-02-10）

**致命的な問題: サブエージェントの要約によりスライド品質・情報量が大幅低下**

- サブAgent（DeepSeek V3.2）が検索結果を要約すると、メインAgent（Sonnet）が受け取る情報が大幅に減少
- Sonnetが持つ「詳細な検索結果から重要な情報を取捨選択してスライドを構成する」能力が活かせない
- 要約段階でDeepSeekが重要と判断しない情報がカットされ、スライドの深みが失われる
- **コスト削減 vs 品質のトレードオフが許容範囲を超えている**

#### 検索クエリ通知の調査結果

現在、メインAgentのストリーミングイベント `current_tool_use` で `web_search` のクエリを検知し、フロントにリアルタイム表示している。サブAgent化するとこのイベントが取れなくなるため、3つのアプローチを調査した。

| アプローチ | 概要 | フロント変更 | 実装量 |
|-----------|------|------------|--------|
| **A: ツール内LLM直接呼び出し** | `web_search`内でboto3 Converse APIで要約。ツール名変更なし | 不要 | 最小 |
| **B: サブAgent+カスタムcallback** | サブAgentのcallback_handlerでクエリをキャプチャ→グローバル変数経由で通知 | あり | 大 |
| **C: search_and_summarizeの引数利用** | `search_and_summarize(query)`の引数をフロントに表示 | マッピング要 | 中 |

**Strands Agentsの制約**: サブAgent内部のツール呼び出しイベントは親Agentの`callback_handler`に自動伝播しない。各Agentは独立したイベントスコープを持つ。

#### 方針転換: ノイズ除去パターン（2026-02-10）

**根本原因の再分析**: 品質劣化の原因は「サブエージェント化」ではなく「要約プロンプト」にあった。
「箇条書き3〜5項目に要約」という指示が情報を75%捨てており、Sonnetの判断力が活かせなかった。

**方針転換**: 「要約して情報を捨てる」→「ノイズだけ除去して重要情報は原文保持」

Tavilyクレジットも逼迫しているため、検索回数は増やさず1回のまま。
DeepSeek V3.2（AWSクレジットで実質無料）のサブエージェントで、検索結果のノイズ除去のみを行う。

**ノイズ除去パターンの概要**:

```
メインAgent (Sonnet)
  → search_and_summarize(query)
    ┌────────────────────────────────────────┐
    │ DeepSeek V3.2 サブAgent（コスト=実質無料）  │
    │                                        │
    │ 1. web_search × 1回（現状と同じ）          │
    │ 2. ノイズ除去（広告・ナビ・冗長表現のみ）    │
    │ 3. 重要情報は原文のまま保持                 │
    └────────────────────────────────────────┘
  → ノイズ除去済みの情報（~1,200トークン）でスライド生成
```

**変更点**:
- ツール名: `search_and_summarize`（変更なし）
- サブAgentプロンプト: 「要約」→「ノイズ除去+原文保持」
- 検索回数: 1回（変更なし、Tavilyクレジット消費増なし）
- 情報量: 2,000tok → ~1,200tok（ノイズ除去分のみ削減）
- フロント変更: なし（バックエンドで`web_search`として通知）
- フォールバック: サブAgent失敗時はweb_searchを直接呼び出し

**コスト影響**:

| 項目 | 旧サブAgent（要約） | ノイズ除去パターン |
|------|-------------------|------------------|
| DeepSeek V3.2 | 実質無料 | 実質無料 |
| Tavily検索回数 | 1回/呼び出し | 1回/呼び出し（変更なし） |
| Sonnet入力トークン | ~500（要約しすぎ） | ~1,200（ノイズ除去のみ） |
| スライド品質 | 低下 | **維持**（重要情報は原文保持） |
| トークン削減率 | -75%（過剰） | **-40%（適正）** |

#### サブエージェントのモデル

| モデル | Bedrock ID | 入力単価 | コスト効率 |
|--------|-----------|---------|-----------|
| **DeepSeek V3.2** | `deepseek.v3.2` | ~$0.28/M | Sonnet比 **1/11** |
| **Claude Haiku** | `us.anthropic.claude-haiku-4-5-20251001-v1:0` | $1.00/M | Sonnet比 **1/3** |
| **Nova Pro** | `us.amazon.nova-pro-v1:0` | $0.80/M | Sonnet比 **1/3.75** |

> DeepSeek V3.2はクロスリージョン推論プロファイルなし（`deepseek.v3.2` で直接呼び出し）。

#### 変更対象ファイル（実装済み・revert済み）

| ファイル | 変更内容 |
|---------|---------|
| `tools/search_and_summarize.py` | **新規** サブエージェントツール定義（ブランチに残存） |
| `tools/__init__.py` | エクスポート追加 → revert済み |
| `session/manager.py` | ツールリスト変更 → revert済み |
| `agent.py` | ツール名判定変更 → revert済み |
| `config.py` | System Prompt変更 → revert済み |

---

### 【既存施策】施策2: 会話履歴のトリミング ✅ 実装済み

- **効果**: 大
- **工数**: **小**（Strands Agents組み込み機能を活用）
- **対象**: `amplify/agent/runtime/session/manager.py`

#### 変更内容

- Strands Agentsの `SlidingWindowConversationManager` を導入（`window_size=6`、初期値10から調整）
- Agent生成時に `conversation_manager` 引数を追加するだけで実現
- フロントエンドが修正リクエスト時に最新Markdown全文を毎回送信するため、古い履歴が消えても会話は成立する

```python
from strands.agent.conversation_manager import SlidingWindowConversationManager

agent = Agent(
    model=model,
    system_prompt=SYSTEM_PROMPT,
    tools=tools,
    conversation_manager=SlidingWindowConversationManager(window_size=6),
)
```

---

### 【既存施策】施策3: Markdown二重送信の解消 ✅ 実装済み

- **効果**: 中
- **工数**: 小
- **対象**: `amplify/agent/runtime/agent.py`

#### 変更内容

- 既存セッション（`agent.messages` に前回のスライド内容が残っている）ではMarkdown付加をスキップ
- 新規セッションまたは履歴がない場合のみ、フロントからのMarkdownをメッセージに結合
- フロントエンド側は変更なし（`markdown` フィールドは引き続き送信し、PDF/PPTX/共有機能で使用）

---

### 【新規施策】施策4: キャッシュヒット率の向上 ⭐ 即効性あり

- **効果**: 大（キャッシュ率9%→50%で入力コスト約40%削減）
- **工数**: 中
- **対象**: `amplify/agent/runtime/session/manager.py`, `amplify/agent/runtime/config.py`

#### 現状の問題

- キャッシュヒット率が平均9%と極めて低い
- キャッシュRead単価は通常入力の**10分の1**（$3.00 → $0.30/MTok）
- キャッシュがもっと効けば、入力トークンコストの大幅削減が可能

#### 改善策

1. **1時間キャッシュの活用**: デフォルトの5分キャッシュ→1時間キャッシュに変更。ピーク時（1時間で全体の35%消費）に効果大
   - Write: $3.75 → $6.00/MTok（高くなる）
   - Read: $0.30/MTok（変わらず）
   - セッション数が多い時間帯では、Write1回→Read多数回でペイする
2. **System Promptの固定化**: 動的要素をSystem Promptの末尾にまとめ、冒頭部分のキャッシュを安定化
3. **会話履歴のプレフィックス安定化**: 施策2と組み合わせて、履歴を短く保つことでキャッシュプレフィックスの一致率を上げる

#### 期待効果

- キャッシュ率を9% → 40-50%に向上できれば
- 入力トークンのうちキャッシュReadで処理される分: コスト**90%削減**
- 全体で**約20-30%のコスト削減**

> 参考: [Effectively use prompt caching on Amazon Bedrock](https://aws.amazon.com/blogs/machine-learning/effectively-use-prompt-caching-on-amazon-bedrock/)

---

### 【新規施策】施策5: System Prompt & ツール定義の圧縮 ✅ 実装済み

- **効果**: 中（入力トークン10-15%削減）
- **工数**: 小
- **対象**: `amplify/agent/runtime/config.py`, ツール定義各ファイル

#### 現状分析

現在の`SYSTEM_PROMPT`（`config.py:22-112`）は約1,500トークン。内訳:
- Marp記法のサンプルコード（コードブロック）が大部分を占める
- 類似の指示が重複している箇所あり
- ツール使用時の隠しシステムプロンプト: +346トークン（Claude自動付加）

#### 改善策

1. **コードサンプルの簡略化**: Marpフォーマットの例を最小限に
2. **重複指示の統合**: 検索エラー時の対応など、冗長な記述を圧縮
3. **不要ツールの条件付きロード**: `generate_tweet_url`は利用頻度が低い → 必要時のみロードすればツール定義のトークンを節約
4. **ツール説明文の最適化**: 各ツールの`docstring`を簡潔に

#### 期待効果

- System prompt: 1,500 → 1,000トークン（-500）
- 毎リクエストで500トークン × 1,300セッション/日 = 65万トークン/日削減
- コスト: 約$2/日削減

---

### 【新規施策】施策6: ユーザーごとの利用制限

- **効果**: 大（ピーク時コストの直接制御）
- **工数**: 中
- **対象**: `amplify/agent/runtime/agent.py`

#### 概要

- 1ユーザーあたりの日次リクエスト上限を設定（例: 20回/日）
- ピーク時の爆発的利用を防止
- 全体の35%が1時間に集中している現状を緩和

#### 実装方法

- AgentCore Memoryまたはシンプルなインメモリカウンターで利用回数を追跡
- 上限到達時に「本日の利用上限に達しました」とメッセージ表示

#### 期待効果

- ピーク時のコスト上限を設定可能
- ヘビーユーザーによるコスト集中を防止

---

## 施策の優先順位と進捗

| 順番 | 施策 | 工数 | 期待効果 | 状態 |
|------|------|------|----------|------|
| 1 | **施策2: 会話履歴トリミング** | 小 | 大 | ✅ 実装済み・テスト中 |
| 2 | **施策5: System Prompt圧縮** | 小 | 中 | ✅ 実装済み・テスト中 |
| 3 | **施策3: Markdown二重送信の解消** | 小 | 中 | ✅ 実装済み・テスト中 |
| 4 | **施策4: キャッシュヒット率向上** | 中 | 大（-20~30%） | 未着手 |
| 5 | **施策6: ユーザー利用制限** | 中 | 大 | 未着手 |
| 6 | **施策1: Web検索サブエージェント** | 中 | - | 断念（品質低下が不可避） |

> **方針**: 工数「小」の施策（2, 5, 3）を先に片付けて即効性のあるコスト削減を実現。
> 施策2→5→4の順は相乗効果あり（履歴が短い＋System Prompt安定 → キャッシュヒット率が最大化）。
> 工数が大きい施策1は小さな施策で成果を出してから着手。
>
> ※施策3の注意: 施策2は「フロントから毎回Markdownが送られる」ことを前提としている。
> 施策3でフロント側のMarkdown送信をスキップするとこの前提が崩れるため、
> バックエンド側（`agent.py:74-75`）の二重付加のみ削除し、フロントからの送信は維持する。

### 実装ログ

| 日時 | 内容 |
|------|------|
| 2026-02-10 | `cost-reduction` ブランチを作成、施策2,3,5を実装 |
| 2026-02-10 | トークンメトリクスのログ出力を追加（`version: cost_opt_v1`） |
| 2026-02-10 | Amplifyにデプロイ → テスト時にSSEアイドルタイムアウト（10秒）でエラー発生 |
| 2026-02-10 | SSEアイドルタイムアウト機能を完全に削除して再デプロイ |
| 2026-02-10 | 施策1実装: サブエージェント化（DeepSeek V3.2）、並列呼び出し対応、クエリ通知マッピング |
| 2026-02-10 | 施策1テスト: 動作確認OK、ただし要約による**スライド品質・情報量の大幅低下**を確認 |
| 2026-02-10 | 施策1をrevert（品質問題のため）、`search_and_summarize.py`はブランチに残存、代替アプローチ要検討 |
| 2026-02-10 | 施策1: ノイズ除去パターンも検証 → サブエージェント経由では品質低下が不可避のため断念 |
| 2026-02-11 | 施策2: CloudWatchログ分析に基づき `window_size` を10→6に調整（追加-35%削減見込み） |

## 全施策のコスト削減効果（試算）

| 施策 | 個別効果 | 累積後の日額 |
|------|---------|-------------|
| 現状 | - | $30/日 |
| 施策2: 会話履歴トリミング | -$2/日 | $28/日 |
| 施策5: System Prompt圧縮 | -$2/日 | $26/日 |
| 施策3: Markdown二重送信解消 | -$2/日 | $24/日 |
| 施策4: キャッシュヒット率向上 | -$5/日 | $19/日 |
| 施策1: Web検索サブエージェント | -$4/日 | $15/日 |
| **全施策実施後** | **-50%** | **$15/日（月$450）** |

> 注: 各施策の効果は独立ではなく、組み合わせで重複する部分がある。上記は保守的な見積もり。
> 施策6（利用制限）は上記に含まず、追加で削減可能。

---

## 効果測定

### メトリクスログ

`agent.py` でリクエストごとにトークン使用量をJSON形式でログ出力（`version` タグ付き）。

```json
{"type": "METRICS", "version": "cost_opt_v1", "session_id": "xxx", "model_type": "sonnet", "input_tokens": 4500, "output_tokens": 1200, "cache_read_tokens": 500, "cache_write_tokens": 1500}
```

### CloudWatch Log Insights クエリ

```
# 施策前後の比較（バージョン別の平均トークン数）
filter type = "METRICS"
| stats avg(input_tokens) as 平均入力, avg(output_tokens) as 平均出力,
        avg(cache_read_tokens) as 平均キャッシュRead, count(*) as セッション数
  by version, bin(1h)
```

```
# キャッシュヒット率の確認
filter type = "METRICS"
| stats sum(cache_read_tokens) / sum(input_tokens) * 100 as キャッシュ率,
        count(*) as リクエスト数
  by version, bin(1h)
```

### バージョン履歴

| version | 内容 | デプロイ日 |
|---------|------|-----------|
| (なし) | 施策前（ログ出力なし） | - |
| `cost_opt_v1` | 施策2,3,5 実施 + SSEタイムアウト削除 | 2026-02-10 |
| `cost_opt_v2` | Tavily search_depth: advanced→basic, max_results: 5→3 | 2026-02-10 |
| `cost_opt_v3` | Web検索サブエージェント化（ノイズ除去パターン、DeepSeek V3.2） | 2026-02-10 |

### 効果検証（2026-02-10 実測）

#### データソース

カスタム `METRICS` ログ（`print()` 出力）はAgentCoreのOTelログストリームに載らず **未出力**。
代わりに **Strands Agents組み込みのEMF（Embedded Metric Format）** からトークンデータを取得。

```
# 使用したCloudWatch Log Insightsクエリ
filter @message like /strands.event_loop.input.tokens/
| fields @timestamp, @message
| sort @timestamp asc
```

メトリクス名:
- `strands.event_loop.input.tokens` / `strands.event_loop.output.tokens`
- `strands.event_loop.cache_read.input.tokens` / `strands.event_loop.cache_write.input.tokens`

#### cost-reductionブランチ テストセッション実測値

**Session 1**（12:42 JST、簡易テスト）

| ターン | 入力 | 出力 | Cache Read | Cache Write |
|--------|------|------|-----------|-------------|
| 1（初回） | 495 | 278 | 0 | 2,043 |
| 2（Web検索+生成） | 7,717 | 190 | 4,086 | 0 |

**Session 2**（16:41 JST、コスト削減スライド生成＋修正2回）

| ターン | 入力 | 出力 | Cache Read | Cache Write |
|--------|------|------|-----------|-------------|
| 1（初回） | 494 | 224 | 0 | 2,043 |
| 2（Web検索+スライド生成） | 39,994 | 5,089 | 4,086 | 0 |
| 3（修正リクエスト） | 22,838 | 3,713 | 2,043 | 0 |
| **合計** | **63,326** | **9,026** | **8,172** | **2,043** |

#### mainブランチ ベースライン（7日間・500リクエスト）

| 指標 | 値 |
|------|-----|
| リクエスト数 | 500件（7日間） |
| 平均入力トークン | 43,261 |
| 中央値入力トークン | 24,760 |
| 最大入力トークン | **268,848** |
| 平均出力トークン | 1,707 |
| キャッシュヒット率 | 8.7% |
| System Prompt + Tools（Sonnet） | **3,073** トークン |
| 100K超リクエスト | **50件（10%）** |
| 日別平均コスト（EMF算出） | $11.13/日 |

日別内訳:

| 日付 | リクエスト数 | 平均入力 | 推定コスト |
|------|------------|---------|-----------|
| 2/3 | 26 | 41,641 | $4.44 |
| 2/4 | 44 | 30,748 | $5.84 |
| 2/5 | 54 | 45,942 | $9.38 |
| 2/6 | 95 | 40,120 | $14.55 |
| 2/7 | 69 | 36,460 | $9.05 |
| 2/8 | 73 | 60,041 | $15.35 |
| 2/9 | 106 | 40,308 | $16.32 |
| 2/10 | 33 | 19,807 | $2.99（途中） |

#### 施策別の実測効果

**施策5（System Prompt圧縮）**:
- Sonnet: 3,073 → 2,043トークン = **-1,030 tokens（-33.5%）**
- 推定削減: $0.24/日

**施策2（会話履歴トリミング）**:
- mainで50件（10%）が100K超→最大268Kまで膨張
- window_size=10 で50K以下に抑制可能
- 推定削減: **$2.80/日**（最大効果）

**施策3（Markdown二重送信解消）**:
- Session 2のTurn 3（22,838）がTurn 2（39,994）より大幅減で効果確認
- 推定削減: $0.08/日

**合計推定削減**: **$3.12/日（EMFベースで28%削減）**

> ※ EMFデータは全コストをカバーしていない可能性あり。Bedrock請求ベースの$30/日に対しては約$8/日（27%）削減と推定。

#### カスタムMETRICSログが出力されない問題

`agent.py:119-131` の `print(json.dumps({...}))` がCloudWatch Logsに未出力。

- **原因**: AgentCoreランタイムのstdoutがOTelログストリーム(`otel-rt-logs`)に載らない
- **代替**: Strands Agents組み込みEMFで同等データが取得可能
- **対応**: カスタムMETRICSログのコードは削除し、EMFクエリに統一する

---

## スコープ外

### Web検索パラメータの変更（施策1で不要に）

- `max_results` や `search_depth` の変更はスライド品質低下リスクがある
- 施策1（サブエージェント）により、検索はフルパワーのまま要約で圧縮できるため不要

### バッチ推論（50%割引）

- バッチAPIは非同期処理向け（50%割引）だが、本アプリはリアルタイムストリーミングが必須のため適用不可

### AgentCore Runtime自体のコスト最適化

- AgentCore Runtimeは消費ベース課金（CPU/メモリの秒単位）
- I/O待機中（LLMレスポンス待ち）はCPU課金なし
- 現状のアーキテクチャではLLMコストが99%を占めるため、Runtime側の最適化は優先度低

## 参考情報

- [Amazon Bedrock Pricing](https://aws.amazon.com/bedrock/pricing/)
- [Claude Pricing](https://platform.claude.com/docs/en/about-claude/pricing)
- [Amazon Nova Pricing](https://aws.amazon.com/nova/pricing/)
- [Bedrock Cost Optimization](https://aws.amazon.com/bedrock/cost-optimization/)
- [Effectively use prompt caching on Amazon Bedrock](https://aws.amazon.com/blogs/machine-learning/effectively-use-prompt-caching-on-amazon-bedrock/)
- [Effective cost optimization strategies for Amazon Bedrock](https://aws.amazon.com/blogs/machine-learning/effective-cost-optimization-strategies-for-amazon-bedrock/)
- [AgentCore Pricing](https://aws.amazon.com/bedrock/agentcore/pricing/)
- [AgentDiet: Token Reduction Framework](https://arxiv.org/html/2601.14470) - 入力トークン40-60%削減の研究
- [Agentic Plan Caching](https://arxiv.org/abs/2506.14852) - 類似タスクのプラン再利用

---

## 追記: 本番環境での効果検証（2026-02-10 CloudWatch実測）

### 検証方法

**ログ期間**: 
- 施策前: 2026-02-08 00:00 - 2026-02-10 00:00 UTC（48時間）
- 施策後: 2026-02-10 04:48 - 2026-02-10 10:48 UTC（6時間、デプロイ約2時間後～）

**ログソース**: `/aws/bedrock-agentcore/runtimes/marp_agent_main-vE9ji6BCaL-DEFAULT` の otel-rt-logs ストリーム

**取得方法**: Strands Agents EMFから直接メトリクスを抽出

```bash
aws logs filter-log-events \
  --log-group-name "/aws/bedrock-agentcore/runtimes/marp_agent_main-vE9ji6BCaL-DEFAULT" \
  --filter-pattern 'strands.event_loop.input.tokens' \
  --start-time 1707436800000 \
  --end-time 1707543600000 \
  --region us-east-1 \
  --query 'events[*].message' \
  --output text
```

### 検証結果サマリ

| 指標 | 施策前（48h） | 施策後（6h） | 改善 |
|------|------------|----------|------|
| **リクエスト数** | 70件 | 27件 | - |
| **平均入力** | 36,359 | 21,762 | -40.1% |
| **最大入力** | 165,758 | 94,260 | -43.1% |
| **100K超リクエスト** | 4件 (5.7%) | 0件 (0%) | -100% |
| **キャッシュ効率** | 1.9% | 20.6% | +18.6pt |
| **平均コスト/req** | $0.13202 | $0.09471 | -28.3% |

### 詳細分析

#### 1. 入力トークン削減（40.1%）

**施策の寄与度推定**:

| 施策 | 推定削減量 | 根拠 |
|------|----------|------|
| 施策2（履歴トリミング） | ~20,000 tok | 100K超リクエストの完全排除 |
| 施策5（System Prompt圧縮） | ~1,030 tok | 実測値: 3,073→2,043 tokens |
| 施策3（Markdown二重送信解消） | ~1,000 tok | 複数ターン会話での重複削減 |
| **合計** | **~22,000 tok** | **実測削減: 14,597 tok** |

**解釈**: 施策2の履歴トリミングが支配的効果。新規セッションは影響を受けないため、複数ターン会話比率によって削減率が変動する可能性あり。

#### 2. 大型リクエスト（100K超）の完全削減

**施策前の分布**:
- 129,939 tokens
- 136,152 tokens
- 139,295 tokens
- **165,758 tokens（最大）**

**施策後**: 0件

**意義**: 100K超のリクエストは通常の3倍以上のコスト。これが完全に排除されたことで、コスト分布が正常化。

#### 3. キャッシュ効率の10倍以上改善（1.9% → 20.6%）

**キャッシュ読込の急伸**:

```
施策前: 平均 702 tokens/request
施策後: 平均 4,476 tokens/request
─────────────────────────────
増加: 537%
```

**根本原因**: System Promptのコンパクト化により、キャッシュプレフィックスの一致率が向上。

**料金への影響**:
- キャッシュ読込: $0.30/M tokens（通常入力の10分の1）
- この10倍の読込増加は、ほぼコスト増加なし（むしろ削減）

#### 4. 月間推定コスト削減

**保守的推定（同一リクエスト量を仮定）**:
```
施策前: $138.62/月（70req/48h ベース）
施策後: $99.45/月
削減:   $39.18/月 （28.3%削減）
```

**実運用ベース（計画書P.364の $30/日 から推定）**:
```
施策前: $30/日
施策後: $21.50/日（28.3%削減）
月間削減: 約 $255/月
```

### 未実装施策による追加削減

| 施策 | 現状 | 期待効果 | 工数 |
|------|------|---------|------|
| **施策4: キャッシュ1時間化** | キャッシュTTL 5分 | -20~30%入力コスト | 中 |
| **施策1: Web検索サブエージェント** | 未実装 | -33%入力トークン | 大 |
| **施策6: ユーザー利用制限** | 未実装 | ピーク制御 | 中 |

### 注意事項と次ステップ

#### ⚠️ データの統計的信頼性

- 施策後は6時間27リクエストのみ
- 推奨観測期間: 48-72時間以上
- **次のアクション**: 2-3日継続して観測し、データを厚くする

#### 🔍 AWS Cost Explorer との照合

CloudWatch EMFから計算した削減率が、実際の請求額に反映されるかを確認:
- EMF計算: 28.3%削減
- 請求ベース: $30/日 → $21.50/日 の削減確認待ち

#### ✅ 施策4実装の優先度

キャッシュTTLを5分→1時間に拡張すれば、さらに20-30%の削減が見込める。現在のキャッシュ効率が20.6%まで向上したため、TTL拡張の効果が最大化される見込み。

---

## window_size チューニング調査（2026-02-11 CloudWatch実測）

### 調査目的

`SlidingWindowConversationManager(window_size=10)` の値をどこまで下げてもスライド品質に影響しないかを、CloudWatchログの実データから分析する。

### SlidingWindowConversationManager の仕様

- `window_size` は **メッセージ数**（ターン数ではない）
- デフォルト値: 40メッセージ
- トリミングアルゴリズム（2段階）:
  1. 古いツール結果を `"The tool result was too large!"` に圧縮（メッセージ数は減らさない）
  2. それでも超えていたら古いメッセージを削除（toolUse/toolResultペアの整合性を保持）
- `per_turn=False`（デフォルト）: エージェントループ完了後にのみトリミング実行（処理中は全メッセージ利用可能）

### 典型的なメッセージ数

1回のユーザーリクエスト（web_search + output_slide）で生成されるメッセージ:

```
[user]      ユーザーメッセージ          ... 1
[assistant] toolUse: web_search         ... 2
[user]      toolResult: 検索結果        ... 3
[assistant] toolUse: output_slide       ... 4
[user]      toolResult: スライド出力    ... 5
[assistant] 最終テキスト応答           ... 6
```

→ **1リクエスト = 約6メッセージ**

| window_size | 保持できる履歴 | 動作 |
|-------------|--------------|------|
| 10 | ~1.5リクエスト分 | 前回の一部 + 今回の全部 |
| **6** | ~1リクエスト分 | 今回の全部のみ |
| 4 | <1リクエスト分 | 今回のツール結果が一部圧縮される |

### 分析データ

**ログ期間**: 2026-02-10 00:00 - 2026-02-12 00:00 UTC（施策後48時間）
**ログソース**: `/aws/bedrock-agentcore/runtimes/marp_agent_main-vE9ji6BCaL-DEFAULT` otel-rt-logs ストリーム

#### ターン数分布（施策前後比較）

| ターン数 | 施策前 (500件/7日) | 施策後 (48件/2日) |
|---------|-------------------|-------------------|
| 1ターン | 128 (25.6%) | 16 (33.3%) |
| 2ターン | 253 (50.6%) | 19 (39.6%) |
| 3ターン | 79 (15.8%) | 8 (16.7%) |
| 4-5ターン | 34 (6.8%) | 5 (10.4%) |
| 6-7ターン | 6 (1.2%) | 0 (0%) |
| **平均** | **2.1ターン** | **2.1ターン** |

#### 入力トークン分布（施策前後比較）

| 指標 | 施策前 (window_sizeなし) | 施策後 (window_size=10) | 改善 |
|------|------------------------|------------------------|------|
| 平均 | 41,313 | 16,849 | **-59%** |
| 中央値 | 24,851 | 10,151 | -59% |
| P90 | 100,136 | 43,679 | -56% |
| 最大 | 268,848 | 94,260 | -65% |
| 100K超 | 50件 (10.0%) | 0件 (0%) | -100% |

#### ターン数別の入力トークン（セッション合計）

| ターン数 | 施策前 | 施策後 (window_size=10) |
|---------|--------|------------------------|
| 1ターン | 平均18,782 / 最大101,704 | 平均8,908 / 最大43,066 |
| 2ターン | 平均50,579 / 最大242,312 | 平均14,937 / 最大65,259 |
| 3ターン | 平均41,905 / 最大182,240 | 平均29,914 / 最大94,260 |
| 4-5ターン | 平均50,840 / 最大268,848 | 平均30,000 / 最大53,723 |

#### 単一ターンの最大入力トークン分布（施策後）

```
    0-  1,000:   7 #######
1,000-  5,000:  13 #############
5,000- 10,000:  11 ###########
10,000- 20,000:   8 ########
20,000- 30,000:   5 #####
30,000- 50,000:   4 ####
50,000+      :   0
```

### 分析結論

**window_size を下げても安全な根拠**:

1. **フロントエンドが修正リクエスト時に最新Markdown全文を毎回送信する** → 前回のスライド内容は履歴に残す必要がない
2. 73%のセッションが1-2ターン → 多ターン会話はそもそも少ない
3. トリミングはエージェント完了後のみ実行 → 処理中の品質には影響しない

### 対応: window_size を 10 → 6 に変更

**変更日**: 2026-02-11
**変更内容**: `SlidingWindowConversationManager(window_size=6)`

**期待効果**:

| 指標 | window_size=10 | window_size=6（推定） | 追加削減 |
|------|---------------|---------------------|---------|
| 平均入力 | 16,849 | ~11,000 | **-35%** |
| 推定日額 | $21.50/日 | ~$14/日 | **-$7.50/日** |
| 推定月額 | $645/月 | ~$420/月 | **-$225/月** |

**次のステップ**: 2-3日観測して品質問題がなければ `window_size=4` も検討。

